{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AAkDA;;GAEG;AACH,MAAM,CAAN,IAAY,QAgBX;AAhBD,WAAY,QAAQ;IAClB;;;OAGG;IACH,qEAAuB,CAAA;IACvB;;;OAGG;IACH,mEAAsB,CAAA;IACtB;;;OAGG;IACH,yEAAyB,CAAA;AAC3B,CAAC,EAhBW,QAAQ,KAAR,QAAQ,QAgBnB","sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\n\nimport type { DisplayStrings } from './config';\n\nexport interface InitializeOptions {\n  /**\n   * If your app doesn't use Bluetooth scan results to derive physical\n   * location information, you can strongly assert that your app\n   * doesn't derive physical location. (Android only)\n   * Requires adding 'neverForLocation' to AndroidManifest.xml\n   * https://developer.android.com/guide/topics/connectivity/bluetooth/permissions#assert-never-for-location\n   * @default false\n   */\n  androidNeverForLocation?: boolean;\n}\n\nexport interface RequestBleDeviceOptions {\n  /**\n   * Filter devices by service UUIDs.\n   * UUIDs have to be specified as 128 bit UUID strings,\n   * e.g. ['0000180d-0000-1000-8000-00805f9b34fb']\n   * There is a helper function to convert numbers to UUIDs.\n   * e.g. [numberToUUID(0x180f)]. (see [UUID format](#uuid-format))\n   */\n  services?: string[];\n  /**\n   * Filter devices by name\n   */\n  name?: string;\n  /**\n   * Filter devices by name prefix\n   */\n  namePrefix?: string;\n  /**\n   * For **web**, all services that will be used have to be listed under services or optionalServices,\n   * e.g. [numberToUUID(0x180f)] (see [UUID format](#uuid-format))\n   */\n  optionalServices?: string[];\n  /**\n   * Normally scans will discard the second and subsequent advertisements from a single device.\n   * If you need to receive them, set allowDuplicates to true (only applicable in `requestLEScan`).\n   * (default: false)\n   */\n  allowDuplicates?: boolean;\n  /**\n   * Android scan mode (default: ScanMode.SCAN_MODE_BALANCED)\n   */\n  scanMode?: ScanMode;\n}\n\n/**\n * Android scan mode\n */\nexport enum ScanMode {\n  /**\n   * Perform Bluetooth LE scan in low power mode. This mode is enforced if the scanning application is not in foreground.\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_POWER\n   */\n  SCAN_MODE_LOW_POWER = 0,\n  /**\n   * Perform Bluetooth LE scan in balanced power mode. (default) Scan results are returned at a rate that provides a good trade-off between scan frequency and power consumption.\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_BALANCED\n   */\n  SCAN_MODE_BALANCED = 1,\n  /**\n   * Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground.\n   * https://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_LATENCY\n   */\n  SCAN_MODE_LOW_LATENCY = 2,\n}\n\nexport interface BleDevice {\n  /**\n   * ID of the device, which will be needed for further calls.\n   * On **Android** this is the BLE MAC address.\n   * On **iOS** and **web** it is an identifier.\n   */\n  deviceId: string;\n  /**\n   * Name of the peripheral device.\n   */\n  name?: string;\n  uuids?: string[];\n}\n\nexport interface DeviceIdOptions {\n  deviceId: string;\n}\nexport interface TimeoutOptions {\n  /**\n   * Timeout in milliseconds for plugin call.\n   * Default is 10000 for `connect` and 5000 for other plugin methods.\n   */\n  timeout?: number;\n}\n\nexport interface GetDevicesOptions {\n  deviceIds: string[];\n}\n\nexport interface GetConnectedDevicesOptions {\n  services: string[];\n}\n\nexport interface BleService {\n  readonly uuid: string;\n  readonly characteristics: BleCharacteristic[];\n}\n\nexport interface BleDescriptor {\n  readonly uuid: string;\n}\n\nexport interface BleCharacteristic {\n  readonly uuid: string;\n  readonly properties: BleCharacteristicProperties;\n  readonly descriptors: BleDescriptor[];\n}\n\nexport interface BleCharacteristicProperties {\n  readonly broadcast: boolean;\n  readonly read: boolean;\n  readonly writeWithoutResponse: boolean;\n  readonly write: boolean;\n  readonly notify: boolean;\n  readonly indicate: boolean;\n  readonly authenticatedSignedWrites: boolean;\n  readonly reliableWrite?: boolean;\n  readonly writableAuxiliaries?: boolean;\n  readonly extendedProperties?: boolean;\n  readonly notifyEncryptionRequired?: boolean;\n  readonly indicateEncryptionRequired?: boolean;\n}\n\nexport interface BleServices {\n  services: BleService[];\n}\n\nexport interface ReadOptions {\n  deviceId: string;\n  service: string;\n  characteristic: string;\n}\n\nexport interface ReadDescriptorOptions {\n  deviceId: string;\n  service: string;\n  characteristic: string;\n  descriptor: string;\n}\n\nexport type Data = DataView | string;\n\nexport interface WriteOptions {\n  deviceId: string;\n  service: string;\n  characteristic: string;\n  /**\n   * android, ios: string\n   * web: DataView\n   */\n  value: Data;\n}\n\nexport interface WriteDescriptorOptions {\n  deviceId: string;\n  service: string;\n  characteristic: string;\n  descriptor: string;\n  /**\n   * android, ios: string\n   * web: DataView\n   */\n  value: Data;\n}\n\nexport interface BooleanResult {\n  value: boolean;\n}\n\nexport interface GetDevicesResult {\n  devices: BleDevice[];\n}\n\nexport interface ReadRssiResult {\n  value: string;\n}\n\nexport interface ReadResult {\n  /**\n   * android, ios: string\n   * web: DataView\n   */\n  value?: Data;\n}\n\nexport interface ScanResultInternal<T = Data> {\n  device: BleDevice;\n  localName?: string;\n  rssi?: number;\n  txPower?: number;\n  manufacturerData?: { [key: string]: T };\n  serviceData?: { [key: string]: T };\n  uuids?: string[];\n  rawAdvertisement?: T;\n}\n\nexport interface ScanResult {\n  /**\n   * The peripheral device that was found in the scan.\n   * **Android** and **web**: `device.name` is always identical to `localName`.\n   * **iOS**: `device.name` is identical to `localName` the first time a device is discovered, but after connecting `device.name` is the cached GAP name in subsequent scans.\n   */\n  device: BleDevice;\n  /**\n   * The name of the peripheral device from the advertisement data.\n   */\n  localName?: string;\n  /**\n   * Received Signal Strength Indication.\n   */\n  rssi?: number;\n  /**\n   * Transmit power in dBm. A value of 127 indicates that it is not available.\n   */\n  txPower?: number;\n  /**\n   * Manufacturer data, key is a company identifier and value is the data.\n   */\n  manufacturerData?: { [key: string]: DataView };\n  /**\n   * Service data, key is a service UUID and value is the data.\n   */\n  serviceData?: { [key: string]: DataView };\n  /**\n   * Advertised services.\n   */\n  uuids?: string[];\n  /**\n   * Raw advertisement data (**Android** only).\n   */\n  rawAdvertisement?: DataView;\n}\n\nexport interface BluetoothLePlugin {\n  initialize(options?: InitializeOptions): Promise<void>;\n  isEnabled(): Promise<BooleanResult>;\n  enable(): Promise<void>;\n  disable(): Promise<void>;\n  startEnabledNotifications(): Promise<void>;\n  stopEnabledNotifications(): Promise<void>;\n  isLocationEnabled(): Promise<BooleanResult>;\n  openLocationSettings(): Promise<void>;\n  openBluetoothSettings(): Promise<void>;\n  openAppSettings(): Promise<void>;\n  setDisplayStrings(displayStrings: DisplayStrings): Promise<void>;\n  requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice>;\n  requestLEScan(options?: RequestBleDeviceOptions): Promise<void>;\n  stopLEScan(): Promise<void>;\n  getDevices(options: GetDevicesOptions): Promise<GetDevicesResult>;\n  getConnectedDevices(options: GetConnectedDevicesOptions): Promise<GetDevicesResult>;\n  addListener(eventName: 'onEnabledChanged', listenerFunc: (result: BooleanResult) => void): PluginListenerHandle;\n  addListener(eventName: string, listenerFunc: (event: ReadResult) => void): PluginListenerHandle;\n  addListener(eventName: 'onScanResult', listenerFunc: (result: ScanResultInternal) => void): PluginListenerHandle;\n  connect(options: DeviceIdOptions & TimeoutOptions): Promise<void>;\n  createBond(options: DeviceIdOptions): Promise<void>;\n  isBonded(options: DeviceIdOptions): Promise<BooleanResult>;\n  disconnect(options: DeviceIdOptions): Promise<void>;\n  getServices(options: DeviceIdOptions): Promise<BleServices>;\n  readRssi(options: DeviceIdOptions): Promise<ReadRssiResult>;\n  read(options: ReadOptions & TimeoutOptions): Promise<ReadResult>;\n  write(options: WriteOptions & TimeoutOptions): Promise<void>;\n  writeWithoutResponse(options: WriteOptions & TimeoutOptions): Promise<void>;\n  readDescriptor(options: ReadDescriptorOptions & TimeoutOptions): Promise<ReadResult>;\n  writeDescriptor(options: WriteDescriptorOptions & TimeoutOptions): Promise<void>;\n  startNotifications(options: ReadOptions): Promise<void>;\n  stopNotifications(options: ReadOptions): Promise<void>;\n}\n"]}